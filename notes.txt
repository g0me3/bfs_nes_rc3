
ВНУТРЯНКА

1. В игре как минимум три разных дефолтных таблицы рекордов. Одна используется на старте, одна врисована в дефолтную тайловую карту экрана таблицы рекордов (в ней есть неизвстное имя, повторенное 4 раза) и одна совершенно неиспользованная. В последней имена разработчиков такие же, только 6 и 4 поменяны местами и другие очки игроков с максимум аж в более чем миллион.
2. Игра изначально планировалась для двух игроков поочереди на одном контроллере, от этого остались внутренний индекс текущего игрока, бекапы параметров игроков в отдельный архивный массив и выборка их перед новым уровнем. Хотя инитится оба бекапа, индекс игрока в игре никогда не меняется и всегда выбирается только нулевой. В некоторых случаях игра выбирает переменные форсом без учета текущего игрока, как например продолжения - она считает их только у первого игрока, одновременно переменная бекапа континуя для первого игрока работает как глобальная переменная текущего количества континуев и не переписывается в отдельную переменную, как все другие параметры.
3. Количество энергии и эффективность Робокопа оценивается по 8-битной циклической суме процентов защиты. Это подразумевает теоретическую ситуацию, когда сумма ненулевых процентов защиты становится нулем с переполнением и персонаж взрывается. Требуется проверка практической возможности такого варианта в игре.
4. Дефолтная тайловая карта строки состояния игрока содержит строку текста, которая никогда не отображается в игре, так как сразу же затирается другими сообщениями: "A SAMPLE MESSAGE"
5. Перед стартом уровня один раз рассчитывается порог отказа четырех подсистем персонажа, исходя из текущих процентов защиты после починки или продолжения игры. Каждая подсистема с процентом ниже 18 становится потенциальным источником сбоев. Если какой-то из параметров упал ниже уровня во время игры, это не влияет на появление отказов. Отказ той или иной системы персонажа во время игры рассчитывается раз в 100 кадров (примерно раз в 1.5 секунды). Случайным  образом выбирается одна из четырех подсистем и проверяется порог ее отказа. В случае превышения порога, с вероятностью 0.20 выбранной подсистеме выставляется флаг отказа. Если система была в отказе, а очередная проверка на отказ дала отрицательный результат, система восстанавливается с сообщением "ЗАЩИЩАТЬ НЕВИНОВНЫХ". Таким образом каждый отдельный цикл отказа может продолжаться не более 1.5 секунды, но может быть возобновлен на следующие 1.5 секунды или заменен отказом другой.
6. В последнем уровне при истечении таймера происходит немедленный гамовер без каких бы то ни было сообщений. Между тем, перед выходом программа устанавливает запрос на отображение сообщения с индексом 0х1А в строке состояния. В таблице указателей последний индекс - 0х19. Но в блоке текстовых сообщений в самом конце имеется неиспользованная строчка "OUT OF TIME". Очевидно, этот баг просмотрели и если бы не происходил немедленный выход, игру бы сглючивало.
7. В этом же последнем уровне таймер времени отображает минуты и секунды отдельно через пробел, но в коде игры между двумя цифрами ставится ненулевой индекс тайла, который, тем не менее, не имеет графики. Подразумевалось, что здесь будет двоеточие, но оно не было нарисовано по тем или иным причинам.
8. В игре есть две одинаковых функции конвертирования 16-битного 16-ричного числа в пять десятичных в буфере. Одна находится и используется в банке 5, другая - в 7. Причем код обеих процедур довольно универсальный и может использоваться в обоих банках одинаково.
9. В банке графики строки состояния практически нет пустого места. Между тем, там сидят целых четыре разных набора символов для отображения цифр, причем два предназначены для строки сообщений. Ни один из этих двух наборов в игре не используется, так как все сообщения цифр не содержат. При необходимости увеличения количества оружия, можно убрать эти ненужные цифры, на крайний случай оставить только один из них и возможно добавить какие-то сообщения, их использующие.
10. Когда игрок встает на транспортер о втором уровне и тот его несет вперед, при достижении середины экрана вместе с перемещением автоматически включается скролл и скроллит персонажа вместе с экраном, также, как и при обычном перемещении, за это отвечает отдельная ветка в процедуре перемещения на транспортере. В ней же есть отдельная проверка, которая проверяет, не находится ли персонаж в самом конце уровня, стоя на транспортере, если да, то автоскролл пропускается. Таким образом производится своего рода защита уровня от лишнего скролла, так как сам по себе он сделан костылем поверх движка. Но в конце уровня в финальной версии нет достаточно длинного транспортера, чтобы сработала данная защитная ветка, остаток уровня все равно приходится идти ногами и там уже скролл блокируется движком автоматически. По всей видимости, на этапе разработки транспортер был длиннее и сначала сделали такую вот проверку, но потом просто решили укоротить транспортер. Возможно ветка оставлена по соображениям дальнейших возможных изменений уровня, когда транспортер опять может появиться.
11. Пламя от ракетного сопла в третьем уровне у робокопа странно подглючивает. При перемещении горизонтально оно может не только смещаться вправо-влево от нормального значения, но и отделяться от ранца, показывая дыру между ним и пламенем.
12. В режиме ремонта имеется больше графических тайлов, чем используется для отображения повреждений. Ремонт ног рисует фрейм 8х5, хотя в ресурсах предусмотрено 8х6. Кусок кода, отвечающий за рисование, отключен. При попытке его вернуть назад происходит зависание данного режима. Видимо со всеми этими копированиями ребяна не укладывались во время, отведенное на отрисовку перед сменой банка графики посреди экрана. Отсюда, скорее всего, такой метод рисования простынкой из кода с прямым заданием офсетов и засылкой (вместо отправки в ппу фифо). Также целиком не используются три фрейма 4х3 для рисования фаз повреждений кисти левой руки. Все тайлмапы до сих пор сидят в ПЗУ.
13. Некоторые статичные экраны в игре имеют спрайтовый патч для увеличения диапазона отображаемых цветов. Процедура рисования законченного экрана хранит таблицу таких патчей. В отличие от запакованных тайловых карт, патч спрайта - это практически пустой битмап 32х27, где ненулевыми индексами обозначен второй слой картинки, который и преобразуется в спрайты программно. На один такой битмап уходит 864 байта. Всего их должно быть три, но для экрана концовки игры просто не хватило места, патчи этого экрана пишутся напрямую опкодами в спрайтовый буфер в процедуре инициализации рисования. Судя по всему у ребят было так мало времени, что они даже не успели сконвертировать эти патчи во что-то более простое, например в голые спрайтовые данные, либо не было времени писать для этого отдельные инструменты, а проще было дописать процедурку для конвертирования на лету в программе.